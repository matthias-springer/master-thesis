\chapter{Related Work}
\label{sec:related}

\section{Class Name Clashes}

\subsection{Namespaces/Packages and Class Nesting}
Many programming languages have a concept of namespaces or packages. Classes are typically organized in a package, which is a set of classes. Classes within a package can usually reference each other directly. However, references to classes in other packages typically require imports, aliases, or a fully qualified name. Some programming languages also support class nesting, where the enclosing class creates a namespace for all inner/nested classes.

\paragraph{VisualWorks Namespaces}
VisualWorks is a commerical Smalltalk implementation sold by Cincom and supports namespaces~\cite{brauer2015programming}. A namespace is a container for other namespaces, classes, and shared variables. Since a namespace can be defined within another namespace, VisualWorks allows for a form of hierarchical decomposition. All namespace members (e.g., classes) in the same namespace can be referenced by just writing down their names. All namespace members in other namespaces can be referenced by writing down their fully qualified name, which is the concatenation of all nested namespace names and the name of the class with dots as separators. For example, the fully qualified name of a class \texttt{C1} in namespace \texttt{B} in namespace \texttt{A} is \texttt{A.B.C1}. Relatives name are also supported: for example, \texttt{A.B.C1} can be referenced as \texttt{B.C1} within \texttt{A}.

A namespace can import members from other namespaces by specifying a list of all imports when the namespace is defined~\cite{cincomst}. Wildcard imports are possible, importing all members of a namespace. Imported members can be referenced within a namespace as if they were part of that namespace. A namespace member can also be defined as \emph{private}; such a member cannot be imported, but always has to be referenced using its fully qualified name or using a relative name.

Namespaces are instances of the class \texttt{NameSpace}, which is a subclass of \texttt{Collection}. \texttt{NameSpace} defines a few helper methods to allow for meta programming, such as listing all classes or defining new namespaces or classes within a namespace.

\paragraph{Java Packages and Nested Classes}
The Java programming language has a concept of packages. A package is set of classes, interfaces, and pacckages, and corresponds to a directory on the file system. Classes and interfaces in the same package can be referenced directly using their name. Classes and interfaces in other packages can be referenced using their fully qualified name, which is generated exactly as in VisualWorks. They can also be imported explicitly, making it possible to reference them just using their name; wildcard imports are possible.

Classes and interfaces can be defined as package-public or package-private. Only package-public members can be imported or referenced within members outside of the current package.

Java supports the concept of nested classes: a class can either be a top-level class or a class that is nested within another member. There are four different kinds of nested classes~\cite{Bloch:2008:EJ:1377533}.
\begin{itemize}
	\item \emph{Static member class:} a class that belongs to another class, i.e., it is a static member of another class. It can be accessed like a static variable of the enclosing class. For example, if \texttt{B} is nested in \texttt{A}, it can be referenced with \texttt{A.B}. Messages sent from within the nested class are first looked up in the nested class and its superclass hierarchy, then on the class side of the enclosing class (static methods), and then in the enclosing class' enclosing class (if it is a nested class).
	\item \emph{Nonstatic member class:} a class that belongs to an instance of another class, i.e., it is a nonstatic member of another class. It is similar to a static member class, but the method lookup happens on the instance side of the enclosing class. Every instance of a class has its own nonstatic member classes; however, all of these classes must inherit from a class that can be resolved at compile time. Effectively, all nonstatic member classes are the same, with the only exception that they are bound to different enclosing objects.
	\item \emph{Anonymous class:} a class without a name. In older Java versions, it was frequently used as a substitute for missing block closures. Lambda expressions are available since Java 8, making anonymous classes obsolete in many use cases. Note, that since classes are not first-class objects in Java, it is difficult to pass anonymous classes around and to use them in a different context without using meta programming.
	\item \emph{Local class:} a class that can be defined anywhere where a local variable can be defined. It is the least frequently used kind of classes.
\end{itemize}

Static member classes are similar to packages. By just looking at source code that references a static member class, it is not obvious whether the class is statically nested or contained in a package.

Java imposes certain restrictions on member classes. For example, nonstatic member classes are not allowed to have static member which are not final~\cite{javalang1}. Furthermore, a subclass cannot override a member class definition~\cite{igarashi2002inner}; it can just define its own member class. The difference is that overriding implies late binding, which is not the case in Java. With \emph{Jx}, Nystrom et al. changed the Java language is such a way, that subclasses can enhance member classes~\cite{Nystrom:2004:SEV:1028976.1028986}: the new member class overrides the original one and is always a subclass and a subtype of the member class in the superclass. Jx also allows changing the superclass of a member class in a subclass of the enclosing class, a form of mixin modularity.

\paragraph{Ruby Modules}
Ruby has the concept of classes and modules. Modules are classes which are not instantiable. They can be included in classes and be used as mixins. Modules and classes can be nested in each other, defining a namespace. Classes and modules can be accessed using their fully qualified name, which is the concatenation of their names with two colons as separator. For example, if class \texttt{B} is nested in class \texttt{A}, \texttt{B}'s fully qualified named is \texttt{A::B}. Classes and modules can also be accessed using relative names. For example, when accessing \texttt{A::B}, Ruby first looks for \texttt{A} in the current class/module. If there no such member, it looks in the enclosing class/module.

In Ruby, a class can have methods, variables, and constants. An inner class or module is just a constant defined on the enclosing class. Constants are copied or shared during subclassing. Subclasses can replace inner classes with their own implementation. A nested class/module is always a class-side member of their enclosing class/module (nonstatic member class in Java).

In Ruby, classes and modules can be extended after they have been defined. In case of an accidential class/module name clash, the two (or more) classes/modules are effectively merged. In case of colliding methods, the method that was last seen (read from the file) overwrites all previous definitions. This process is often used deliberately in Ruby, in order change the behavior of a library or application, e.g., to fix a known bug (\emph{monkey patching})~\cite{Benson:2008:AR:1386543}. 

\paragraph{Python Modules}
In Python, every source code file is a module. Modules have to be imported, before they can be used within another module. Members defined in a module can be referenced by concatenating the module name and the name of the member (e.g., class or function) inside the module with a dot as a separator, if the module is imported. It is also possible to import single members from a module with their own name or an alias. These members can be accessed without writing down the module name.

In Python, every directory with a \texttt{\_\_init\_\_.py} source code file is a package. Packages can contain other packages and modules. Packages can be imported just like modules. The fully qualified name of a module is the concatenation of all package names and the module name, with a dot as a separator.

Modules in other packages can be imported by writing their fully qualified name or using a path relative to the current module~\cite{pythonp1}.

Python supports inner classes, but only for readability and understandability reasons, and their usage is not wide-spread. Inner classes are class-side members of the enclosing class. In fact, for every inner class, Python creates an attribute on the enclosing class object with the inner class name as name and the inner class object as value. Since all nested class attributes are copied during subclassing, a subclass shares the same inner classes as the superclass. Redefining an inner class on the superclass simply replaces it. Inner classes do not affect the class lookup: for example, when two inner classes nested on the same level want to reference each other, both have to write their \emph{full path} (i.e., sequence of attribute reads).

Whenever a top-level class is defined and there is already a class with that name in the same module, the new class replaces the existing one.

\subsection{Squeak Environments}
\label{sec:rel_sq_env}
A Squeak environment is a mapping of symbols to global objects. Squeak environments were introduced with Squeak~4.5\cite{squeak45notes} and make it possible to have multiple \texttt{globals} dictionaries, effectively establishing namespaces. In fact, \texttt{Smalltalk globals} is an environment. Every class has an \texttt{environment} instance variable determining the environment it belongs to.

Environments establish an association between global identifiers and objects at compile time. For example, if the programmer writes \texttt{Object new} in a method, Squeak looks up \texttt{\#Object} in the environment of the class in which the method is compiled and adds a reference to the result of the lookup in the environment as a method literal. Environments are integrated into the Squeak code base; e.g., the debugger looks up symbols in the corresponding environment when evaluating a code snippet. However, environments lack IDE support at the moment. For example, new environments cannot be created in the system browser as of now.

\paragraph{Name Policies}
An environment can be imported into another environment. This processes copies over all name bindings from the source environment to the target environment. Subsequent changes to the source environment are not reflected in the target environment. In order to solve name conflicts during namespace imports, class names can be changed during import using name policies.

\begin{itemize}
    \item \texttt{AllNamePolicy}: Class names are not changed during import.
    \item \texttt{ExplicitNamePolicy}: The programmer can specify an alias for every class using a dictionary.
    \item \texttt{AddPrefixNamePolicy}: A static prefix is added to every class name during import.
    \item \texttt{RemovePrefixNamePolicy}: A static prefix is removed from every class during import.
\end{itemize}

\paragraph{Example}
Consider, for example, that we want to have two applications \texttt{SpaceCleanup} and \texttt{Breakout} installed in a Squeak image, and both applications provide duplicate class names (e.g. \texttt{Game}), as described in Figure~\ref{fig:use_class_clash}. The programmer has to define separate environments for SpaceCleanup and Breakout, containing only from the respective applications, and importing the system environment, such that system classes like \texttt{String} or \texttt{Morph} are available. The methods in each application can reference \texttt{Game} directly, because the corresponding environment does not contain bindings for the other application.

When the programmer wants to use classes from either one of the two applications, the environment has to be imported into the environment of the classes that need to reference the application classes. If both applications are needed, a name policy must be specified to resolve conflicts. References to the classes in the application must then be replaced with the resolved class name (e.g., with prefix).

\paragraph{Squeak Environments in \msname}
Environments are used in \msname to implement the method \texttt{specification} and the keywords \texttt{enclosing} and \texttt{outer}. Every class has its own environment and these three identifiers are bound to the corresponding objects. \msname does, however, not use environments for class lookup for the following reasons.

\begin{itemize}
    \item Classes are accessed using message sends. Having early-bound classes breaks this notion conceptually, because message sends are always late bound.
    \item Parameterized classes cannot be early bound (bound at compile time), because an instantiations of a parameterized class do not exist until the corresponding class generator method was invoked with the corresponding arguments (which are only known at runtime).
    \item Lazy class initialization is not possible with environments, making source code imports slower, because all referenced class would be created immediately during the import procedure.
    \item Early-bound classes make it more difficult to handle source code changes. Consider, for example, that a method references a nested class contained in the second-level enclosing class, and a class with the same name is added to the first-level enclosing class. In this case, \msname would have to recompile the method (in order to change the binding) and must, therefore, have a cache of all methods that reference a class.
\end{itemize}

\subsection{Newspeak Modules}
Newspeak is a programming language that is inspired by Self and Smalltalk. In Newspeak, classes can be nested, establishing a hierarchical namespace. That namespace is, however, not global~\cite{bracha2008newspeak, Bracha:2011:MDR:1960275.1960310}. All references to external libraries or applications are message sends to a special \texttt{platform} object~\cite{bracha:modules_as_objects}, which is constructed by the application developer, and deserialized and imported when the application is installed. Access to external libraries and also the system libraries is only possible through \texttt{platform}. Basic language classes like \texttt{String}, as well as Squeak class that have not been transformed to Newspeak classes, are an exception: they can be accessed using \texttt{platform blackMarket}~\cite{newspeak101jan}.

\paragraph{Method Lookup}
In Newspeak, all names are late bound. Nested classes can be accessed by sending a message to the enclosing object. The receiver of a message is implicit, i.e., the programmer does not have to write \texttt{self message}, but just \texttt{message}. The lookup mechanism first looks for a corresponding method or nested class in \texttt{self}, then in the lexical scope of the method, and finally in the superclass hierarchy~\cite{bracha:modules_as_objects}. Instance variables can only be accessed through automatically-generated accessor methods.

\msname supports implicit receivers only for unary messages and looks up methods using comb semantics: the lookup starts in \texttt{self}, continues in the superclass hierarchy, and finally traverses the lexical scope of the method. Non-unary selectors cannot have implicit receivers as this would change the Smalltalk syntax. For example, \texttt{message} is a valid Smalltalk statement, but \texttt{message: \#foo} is not. It is, however, a valid Newspeak statement. In \msname, we encourage programmers to make use of implicit receivers only when a class is referenced. In fact, all message sends with implicit receivers are replaced with message sends to \texttt{scope} by the compiler.

\paragraph{Nested Classes}
In Newspeak, nested classes can be defined on the class side and on the instance side. Since all names in Newspeak are late bound, all classes are in fact two mixins: one mixin for the instance side, and one mixin for the class side. Every class is essentially represented by a superclass statement and two mixins that will be applied to the evaluation of the superclass statement (and its meta class)~\cite{Bracha09newspeakprogramming}.

%no need to recompile when inst vars change

\section{Dependency Management}

\subsection{Metacello}
\label{sec:rel_metacello}

\subsection{Java Class Loader}

\subsection{Separate Compilation}

\subsection{Dependency Injection}
%http://www.jot.fm/issues/issue_2012_04/article3.pdf

\subsection{External Configuration in Newspeak}
%https://www.cs.cmu.edu/~aldrich/papers/objects-essay.pdf
%http://bracha.org/newspeak-spec.pdf 6.3.: cannot access class parameters in body

\section{Readability and Understandability}

\subsection{Smalltalk Packages}

\subsection{Hierarchical Decomposition}
Java, Python, Ruby, Newspeak, \ldots

\subsection{Information Hiding with Interfaces}


\section{Code Reuse}

\subsection{Multiple Inheritance}

\subsection{Mixins}
Ruby Modules, Python Multiple Inheritance, Newspeak, Jigsaw

\subsection{Traits}
\label{sec:rel_traits}
Squeak implementation

\subsection{Java Generics}
Java generics allow classes and interfaces to be parameterized by one or multiple classes and interfaces for type checking reasons~\cite{bracha2004generics}. Theya are often used together with collections~\cite{Parnin:2011:JGA:1985441.1985446}. Generic parameters are defined as part of the class or interface definition. When a class or interface is used, the programmer can pass classes and interfaces as arguments.

\begin{figure}[!htp]
\begin{lstlisting}
class Array<T> {
    T[] storage;

    public List(int size) {
        storage = /* ??? */;
    }

    T get(int index) {
        return storage[index];
    }

    void set(int index, T value) {
        storage[index] = value;
    }
}

Array<String> arr = new Array<String>(100);
\end{lstlisting}
\caption{Generic array implementation using Java generics}
\label{fig:rel_java_generics}
\end{figure}

Figure~\ref{fig:rel_java_generics} shows how Java generics are used in practise. \texttt{T} is the generic parameter of the class \texttt{Array}. The compiler ensures that only arguments with the correct type \texttt{T} can be passed to \texttt{set()} and knows that \texttt{get()} can only return objects of type \texttt{T}. 

One shortcoming of Java generics is type erasure: generic type information is only known at compile time, but not at runtime. Therefore, Java actually allocates a storage array of type \texttt{Object[]}. Therefore, it is difficult to initialize \texttt{storage} to an array of type \texttt{T}. In fact, the statement \texttt{new T[size]} does not compile. What the programmer could write instead is an unchecked type cast~\cite{nino2007cost}: \texttt{(T[]) new Object[size]}.

\subsection{C++ Templates}