\chapter{Related Work}
\label{sec:related}
In this chapter, we describe how the problems listed in Section~\ref{sec:problem} were solved in other programming languages, and compare their approaches with \msname.

\section{Duplicate Class Names}
In this section, we describe how other programming languages address the problem of duplicate class names. For example, this problem can occur if multiple libraries provide classes with the same name. When referencing these classes, it is then no longer obvious which class was meant.

\subsection{Namespaces/Packages and Class Nesting}
\label{sec:rel_ns_pkg_cls_nesting}
Many programming languages have a concept of namespaces or packages. Classes are typically organized in a package, which is a set of classes. Classes within a package can usually reference each other directly. However, references to classes in other packages typically require imports, aliases, or a fully qualified name. Some programming languages also support class nesting, where the enclosing class creates a namespace for all inner/nested classes.

\paragraph{VisualWorks Namespaces}
VisualWorks is a commerical Smalltalk implementation by Cincom\footnote{\url{http://www.cincomsmalltalk.com/main/products/visualworks/}} and supports namespaces~\cite{brauer2015programming}. A namespace is a container for other namespaces, classes, and shared variables. Since a namespace can be defined within another namespace, VisualWorks allows for a form of hierarchical decomposition. All namespace members (e.g., classes) in the same namespace can be referenced by just writing down their names. All namespace members in other namespaces can be referenced by writing down their fully qualified name, which is the concatenation of all nested namespace names and the name of the class with dots as separators. For example, the fully qualified name of a class \texttt{C1} in namespace \texttt{B} in namespace \texttt{A} is \texttt{A.B.C1}. Relatives name are also supported: for example, \texttt{A.B.C1} can be referenced as \texttt{B.C1} within \texttt{A}.

A namespace can import members from other namespaces by specifying a list of all imports when the namespace is defined~\cite{cincomst}. Wildcard imports are possible, importing all members of a namespace. Imported members can be referenced within a namespace as if they were part of that namespace. A namespace member can also be defined as \emph{private}; such a member cannot be imported, but always has to be referenced using its fully qualified name or a relative name.

Namespaces are instances of the class \texttt{NameSpace}, which is a subclass of \texttt{Collection}. \texttt{NameSpace} defines a few helper methods to allow for meta programming, such as listing all classes or defining new namespaces or classes within a namespace.

In \msname, a namespace is an uninstantiable nested class. Instead of imports, \msname supports aliases. Wildcard aliases/imports are not supported in \msname. Nested classes can be accessed using message sends instead of extending the Smalltalk syntax with a namespace notation.

\paragraph{Java Packages and Nested Classes}
The Java programming language has a concept of packages. A package is set of classes, interfaces, and packages, and corresponds to a directory on the file system. Classes and interfaces in the same package can be referenced directly using their name. Classes and interfaces in other packages can be referenced using their fully qualified name, which is generated exactly as in VisualWorks. They can also be imported explicitly, making it possible to reference them just using their name; wildcard imports are possible.

Classes and interfaces can be defined as package-public or package-private. Only package-public members can be imported or referenced within members outside of the current package.

Java supports the concept of nested classes: a class can either be a top-level class or a class that is nested within another member. There are four different kinds of nested classes~\cite{Bloch:2008:EJ:1377533}.
\begin{itemize}
	\item \emph{Static member class:} a class that belongs to another class, i.e., it is a static member of another class. It can be accessed like a static variable of the enclosing class. For example, if \texttt{B} is nested in \texttt{A}, it can be referenced with \texttt{A.B}. Messages sent from within the nested class are first looked up in the nested class and its superclass hierarchy, then on the class side of the enclosing class (static methods), and then in the enclosing class' enclosing class (if it is a nested class).
	\item \emph{Non-static member class:} a class that belongs to an instance of another class, i.e., it is a non-static member of another class. It is similar to a static member class, but the method lookup happens on the instance side of the enclosing class. At first glance, it seems that every instance of a class has its own non-static member class; however, all of these classes must inherit from the same class (which can be resolved at compile time). Effectively, all non-static member classes are the same class, with the only exception that they are bound to different enclosing objects; every class has a field holding a reference to the enclosing instance~\cite{Flanagan:2005:JNE:1237908}.
	\item \emph{Anonymous class:} a class without a name. In older Java versions, it was frequently used as a substitute for missing block closures~\cite{sandu1999lambda}. Lambda expressions are available since Java 8, making anonymous classes obsolete in many use cases. Note, that since classes are not first-class objects in Java, it is difficult to pass anonymous classes around (without using the \texttt{java.lang.Class}) and to use them in a different context without using meta programming.
	\item \emph{Local class:} a class that can be defined at any position where a local variable could be defined. It is the least frequently used kind of classes.
\end{itemize}

Static member classes are similar to packages. By just looking at source code that references a static member class, it is not obvious whether the class is statically nested or contained in a package.

Java imposes certain restrictions on member classes. For example, non-static member classes are not allowed to have static members which are not final~\cite{javalang1}. Furthermore, a subclass cannot override a member class definition~\cite{igarashi2002inner}; it can just define its own member class. The difference is that overriding implies late binding, which is not the case in Java. 

\paragraph{Jx}
In \emph{Jx}, Nystrom et al. changed the Java language in such a way, that subclasses can enhance member classes~\cite{Nystrom:2004:SEV:1028976.1028986}: the new member class overrides the original one and is always a subclass and a subtype of the member class in the superclass. This is equivalent to subclassing inherited nested classes in \msname. In Jx, there is no way to completely override a nested class or to extend it without subclassing. The subclass relationship is established implicitly, without using the \texttt{extends} keyword.

References to classes are late bound in a way that, depending on the context, a reference to a nested class can be a reference to the original nested class (in the enclosing superclass) or a reference to the enhanced nested class (in the enclosing subclass).

Jx also allows changing the superclass of a member class in a subclass of the enclosing class, a form of mixin modularity.

\paragraph{Ruby Modules}
Ruby has the concept of classes and modules. Modules are classes which are not instantiable. They can be included in classes and be used as mixins. Modules and classes can be nested in each other, defining a namespace~\cite{Bergel:jucs_11_10:analyzing_module_diversity}. Classes and modules can be accessed using their fully qualified name, which is the concatenation of their names with two colons as separator. For example, if class \texttt{B} is nested in class \texttt{A}, \texttt{B}'s fully qualified named is \texttt{A::B}. Classes and modules can also be accessed using relative names. For example, when accessing \texttt{A::B}, Ruby first looks for \texttt{A} in the current class/module. If there is no such member, it looks in the enclosing class/module.

In Ruby, a class can have methods, variables, and constants. An inner class or module is just a constant defined on the enclosing class. Constants are copied or shared during subclassing. Subclasses can replace inner classes with their own implementation. A nested class/module is always a class-side member of their enclosing class/module (non-static member class in Java).

In Ruby, classes and modules can be extended after they have been defined. In case of an accidential class/module name clash, the two (or more) classes/modules are effectively merged. In case of colliding methods, the method that was last seen (e.g., read from the file system) overwrites all previous definitions. This process is often used deliberately in Ruby, in order to change the behavior of a library or an application, e.g., to fix a known bug (\emph{monkey patching})~\cite{Benson:2008:AR:1386543}. 

\paragraph{Python Modules}
In Python, every source code file is a module. Modules have to be imported, before they can be used within another module. Members defined in a module can be referenced by concatenating the module name and the name of the member (e.g., class or function) inside the module with a dot as a separator, if the module is imported. It is also possible to import single members from a module with their own name or an alias. These members can be accessed without writing down the module name.

In Python, every directory with an \texttt{\_\_init\_\_.py} source code file is a package. Packages can contain other packages and modules. Packages can be imported just like modules. The fully qualified name of a module is the concatenation of all package names and the module name, with dots as separators.

Modules in other packages can be imported by writing their fully qualified name or using a path relative to the current module~\cite{pythonp1}.

Python supports inner classes, but only for readability and understandability reasons, and their usage is not wide-spread. Inner classes are class-side members of the enclosing class. In fact, for every inner class, Python creates an attribute on the enclosing class object with the inner class name as name and the inner class object as value. Since all nested class attributes are copied during subclassing, a subclass shares the same inner classes as the superclass. Redefining an inner class on a subclass simply replaces it. Inner classes do not affect the class lookup: for example, when two inner classes nested on the same level want to reference each other, both have to write their \emph{full path} (i.e., sequence of attribute reads).

Whenever a top-level class is defined and there is already a class with that name in the same module, the new class replaces the existing one.

\paragraph{BETA}
BETA is a statically-typed ``programming language in the Simula tradition''~\cite{LehrmannMadsen:1993:OPB:221048, Kristensen:2007:WWB:1238844.1238854}. BETA does not distinguish between methods and classes, but provides a single abstraction mechanism (\emph{unification}), called the \emph{pattern}. Every pattern has an \emph{object descriptor}, which consists of a list of attribute declarations, optionally a \emph{do-part}, optionally an \emph{enter-part}, and optionally an \emph{exit-part}. 

Patterns can be instantiated, similarly to classes in other programming languages. Instantiated patterns (objects) can be executed, i.e., the do-part is executed. The enter-part serves as a declaration of parameters for the do-part and the exit-part can be used to declare output parameters.

The idea behind unification of classes and methods is that classes can be instantiated, resulting in objects, and methods can be instantiated, resulting in activation records (stack frames).

BETA supports pattern inheritance. In contrast to other programming languages, methods cannot be overwritten in subclasses, but extended. BETA always invokes the base method, which can make an \texttt{inner} call in order to invoke the definition of the subpattern. The rationale behind this design decision is the Liskov substitution principle~\cite{Liskov:1994:BNS:197320.197383}: if the base type is in control of invoking extended behavior, it is easier to ensure that program invariants hold true, even if an instance of a subpattern is used instead of the base pattern. Goldberg et al. argue that both \texttt{super} and \texttt{inner} can be useful in a programming language~\cite{OOPSLA-2004-GoldbergFF}.

In BETA, patterns can be nested. The type of attribute can be either a primitive type (e.g. \texttt{integer}) or another pattern, similarly to class nesting in Newspeak and \msname. Pattern nesting can be used to group patterns that belong together logically~\cite{abstrAndModBETA} and to define interfaces: an interface is a pattern with only virtual attributes. Another pattern can implement that interface by providing a nested pattern which is a subpattern of the interface pattern and extends the interface's nested patterns with concrete implementations~\cite{betaTowardsUnified}.

Nested patterns can be virtual. A virtual pattern can be extended in subpatterns of the enclosing pattern, similarly to subclassing inherited nested classes in \msname. In contrast to \msname, an extended virtual pattern must always be a subtype of the base pattern and cannot be redefined (overwritten)~\cite{madsen1993overview}.

\subsection{Squeak Environments}
\label{sec:rel_sq_env}
A Squeak environment is a mapping of symbols to global objects. Squeak environments were introduced with Squeak~4.5~\cite{squeak45notes} and make it possible to have multiple \texttt{globals} dictionaries, effectively establishing namespaces. In fact, \texttt{Smalltalk globals} is an environment. Every class has an \texttt{environment} instance variable determining the environment it belongs to.

Environments establish an association between global identifiers and objects at compile time. For example, if the programmer writes \texttt{Object new} in a method, Squeak looks up \texttt{\#Object} in the environment of the class in which the method is compiled and adds a reference to the result of the lookup in the environment as a method literal. Environments are integrated into the Squeak code base; e.g., the debugger looks up symbols in the corresponding environment when evaluating a code snippet. However, environments lack IDE support at the moment. For example, new environments cannot be created in the system browser as of now.

\paragraph{Name Policies}
An environment can be imported into another environment. This process copies over all name bindings from the source environment to the target environment. Subsequent changes to the source environment are not reflected in the target environment. In order to solve name conflicts during namespace imports, class names can be changed during import using name policies.

\begin{itemize}
    \item \texttt{AllNamePolicy}: Class names are not changed during import.
    \item \texttt{ExplicitNamePolicy}: The programmer can specify an alias for every class using a dictionary.
    \item \texttt{AddPrefixNamePolicy}: A static prefix is added to every class name during import.
    \item \texttt{RemovePrefixNamePolicy}: A static prefix is removed from every class during import.
\end{itemize}

\paragraph{Example}
Consider, for example, that we want to have two applications \texttt{SpaceCleanup} and \texttt{Breakout} installed in a Squeak image, and both applications provide duplicate class names (e.g. \texttt{Game}), as described in Figure~\ref{fig:use_class_clash}. The programmer has to define separate environments for SpaceCleanup and Breakout, containing only classes from the respective applications, and importing the system environment, such that system classes like \texttt{String} or \texttt{Morph} are available. The methods in each application can reference \texttt{Game} directly, because the corresponding environment does not contain bindings for the other application.

When the programmer wants to use classes from either one of the two applications, the environment has to be imported into the environment of the classes that need to reference the application classes. If both applications are needed, a name policy must be specified to resolve conflicts. References to classes in the application must then be replaced with the resolved class name (e.g., with a prefix).

\paragraph{Squeak Environments in \msname}
Environments are used in \msname to implement the method \texttt{specification} and the keywords \texttt{enclosing} and \texttt{outer}. Every class has its own environment and these three identifiers are bound to the corresponding objects. \msname does, however, not use environments for class lookup for the following reasons.

\begin{itemize}
    \item Classes are accessed using message sends. Having early-bound classes breaks this notion conceptually, because message sends are always late bound.
    \item Parameterized classes cannot be early bound (bound at compile time), because instantiations of a parameterized class do not exist until the corresponding class generator method was invoked with the corresponding arguments (which are only known at runtime).
    \item Lazy class initialization is not possible with environments, making source code imports slower, because all referenced class would be created immediately during the import procedure.
    \item Early-bound classes make it more difficult to handle source code changes. Consider, for example, that a method references a nested class contained in the second-level enclosing class, and a class with the same name is added to the first-level enclosing class. In this case, \msname would have to recompile the method (in order to change the binding) and must, therefore, have a cache of all methods that reference a class.
\end{itemize}

\subsection{Newspeak Modules}
Newspeak is a programming language that is inspired by Self and Smalltalk. In Newspeak, classes can be nested, establishing a hierarchical namespace. That namespace is, however, not global~\cite{bracha2008newspeak, Bracha:2011:MDR:1960275.1960310}. All references to external libraries or applications are message sends to a special \texttt{platform} object~\cite{bracha:modules_as_objects}, which is constructed by the application developer, and deserialized and imported when the application is installed. Access to external libraries and also the system libraries is only possible through \texttt{platform}. Basic language classes like \texttt{String}, as well as Squeak classes that have not been transformed to Newspeak classes, are an exception: they can be accessed using \texttt{platform blackMarket}~\cite{newspeak101jan}.

\paragraph{Method Lookup}
In Newspeak, all names are late bound. Nested classes can be accessed by sending a message to the enclosing object. The receiver of a message is implicit, i.e., the programmer does not have to write \texttt{self message}, but just \texttt{message}. The lookup mechanism first looks for a corresponding method or nested class in \texttt{self}, then in the lexical scope of the method, and finally in the superclass hierarchy~\cite{bracha:modules_as_objects}. Instance variables can only be accessed through automatically-generated accessor methods.

\msname supports implicit receivers only for unary messages and looks up methods using comb semantics: the lookup starts in \texttt{self}, continues in the superclass hierarchy, and finally traverses the lexical scope of the method. Non-unary selectors cannot have implicit receivers as this would change the Smalltalk syntax. For example, \texttt{message} is a valid Smalltalk statement, but \texttt{message: \#foo} is not. It is, however, a valid Newspeak statement. In \msname, we encourage programmers to make use of implicit receivers only when a class is referenced. In fact, all message sends with implicit receivers are replaced with message sends to \texttt{scope} by the compiler.

\paragraph{Nested Classes}
In Newspeak, nested classes can be defined on the class side and on the instance side. Since all names in Newspeak are late bound, all classes are in fact two mixins: one mixin for the instance side, and one mixin for the class side. Every class is essentially represented by a superclass statement and two mixins that will be applied to the evaluation of the superclass statement (and its meta class)~\cite{Bracha09newspeakprogramming}.

%no need to recompile when inst vars change

\section{Dependency Management}
This section gives an overview of how programmers can use external dependencies in other programming languages. Dependency management describes not only the process of how dependencies are installed and organized, but also how they can be included and referenced in an application.

We first describe three methods for referencing external dependencies. Afterwards, we give an overview of how dependencies are installed, stored, and organized in other programming languages.

\subsection{Explicit Dependencies}
This is the simplest form of dependency management. A dependency is referenced by writing down its fully qualified name in the source code. Consider, for example, that a Java programmer wants to write a Paintbrush application, similar to the example shown in Figure~\ref{fig:use_paintbrush}. This application requires a library for reading and writing picture/image files. An external PNG reader/writer library can be referenced by writing down its fully qualified name, e.g., \texttt{ar.com.hjg.pngj.PngReader}\footnote{PNGJ is a Java library for reading and writing PNG images.}. In this section, it is not important how we can ensure that the class \texttt{PngReader} is loaded and available (see Section~\ref{sec:rel_metacello}). What is important is that the programmer explicitly referenced the dependency. Therefore, the application is coupled to that dependency. Changing the dependency requires changing the source code of the application. Note, that referencing dependencies explicitly is not possible in programming languages without a global namespace (e.g., Newspeak).

\subsection{Dependency Injection}
An alternative to explicit dependencies is dependency injection. Instead of referencing dependencies explicitly using their fully qualified name (or using an alias), the programmer writes down a list of all dependencies at one central position: the \emph{injector} knows about all dependencies and ensures that clients have access to dependencies when needed. Whenever a dependency is required in the source code, the programmer uses an implementation-independent interface instead of the concrete implementation (if the language is statically typed) and adds a source code annotation. The source code annotation ensures that the system \emph{injects} the dependency~\cite{Prasanna:2009:DI:1795686}. This makes dependency management easier, because dependencies are listed at one central position, whereas they were scattered across the application in the previous example.

\paragraph{Google Guice}
Guice\footnote{\url{https://github.com/google/guice}} is a framework for dependency managment in Java. The programmer has to create and define a so-called \emph{module}\footnote{Modules in Guice are not to be confused with modules in \msname.}, which binds interfaces to implementations~\cite{Vanbrabant:2008:GGA:1373340}. Consider, for example, that there is an interface \texttt{ImageReader} that is implemented by \texttt{PngReader}. Figure~\ref{fig:rel_dep_inj_guice} shows how the programmer defines the module binding \texttt{ImageReader} to \texttt{PngReader} and uses the reader in \texttt{Paintbrush}. Note, that \texttt{Paintbrush} does not reference \texttt{PngReader} directly, but just an abstract interface. The \texttt{Paintbrush} class is decoupled from the concrete reader class. The PNG reader class could easily be replaced with a reader class reading a different file format by just modifying the module, as long as the new reader class also implements the interface \texttt{ImageReader}.

\begin{figure}[!htp]
\begin{lstlisting}
<@\textbf{import}@> ar.com.hjg.pngj.PngReader;
<@\textbf{import}@> com.google.inject.AbstractModule;
<@\textbf{import}@> org.imageformats.ImageReader;

<@\textbf{public class}@> PaintbrushModule <@\textbf{extends}@> AbstractModule {
    @Override
    <@\textbf{public void}@> configure() {
        bind(ImageReader.<@\textbf{class}@>).to(PngReader.<@\textbf{class}@>);
    }
}
\end{lstlisting}

\begin{lstlisting}
<@\textbf{import}@> org.imageformats.ImageReader;

<@\textbf{public class}@> Paintbrush {
    @Inject
    <@\textbf{private}@> ImageReader reader;

    <@\textbf{public void}@> loadImage(String fileName) {
        <@\textcolor{gray}{\textit{/* ... */}}@>
        Bitmap bitmap = reader.readFile(fileName);
        <@\textcolor{gray}{\textit{/* ... */}}@>
    }
}
\end{lstlisting}

\caption[Example: Dependency injection with Google Guice]{Example: Dependency injection with Google Guice. A module binds interfaces to implementations and dependencies in the application code are annotated with \texttt{@Inject}.}
\label{fig:rel_dep_inj_guice}
\end{figure}

Note, that the example in this paragraph shows only the very basic functionality of Google Guice. More advanced features are available, for example, ensuring that an injected implementation is a singleton instance. Dependency injection is also used heavily in Java test cases, to ensure that a test uses a mock implementation~\cite{Yang:2008:ESU:1395083.1395674}. Another popular dependency injection framework for Java is the Spring Framework\footnote{\url{http://projects.spring.io/spring-framework/}}.

\paragraph{Seuss}
Seuss is a framework for dependency injection in Pharo/Smalltalk~\cite{JOT:issue_2012_04/article3}. Whenever a dependency is required in a class, an instance variable and a corresponding setter method should be added. The setter method must have an \texttt{inject} pragma, telling the framework that a dependency must be injected upon instance creation. For example, if a class requires an image reader class as a dependency, the programmer could add an instance variable setter method with the \texttt{<inject: \#ImageReader>} pragma. The framework allows binding the symbol \texttt{\#ImageReader} to a concrete object at a different position in the code. 

The authors of Seuss argue, that Seuss can help getting rid of static methods, which are often used as accessor methods for \emph{globally visible services}, where the corresponding class acts as a namespace. Seuss can also make test code simpler, because implicit dependencies are resolved and delegated to the injector. Furthermore, the abstract factory pattern becomes obsolete.

\subsection{External Configuration in Newspeak}
In Newspeak, methods cannot access other top-level classes, because there is no global namespace. At the same time, there is no form of dependency injection that would provide dependencies where needed. Instead, Newspeak has the notion of a \texttt{platform}, a dictionary-like data structure containing references to all dependencies. During module/class instantiation, all dependencies should be acquired from \texttt{platform}, which is passed as an argument in the constructor, and stored in slots (instance variables), so that they can be used within modules~\cite{bracha:modules_as_objects}. This is necessary because, in contrast to \msname, class bodies (methods etc.) in Newspeak do not have access to class parameters~\cite{Bracha09newspeakprogramming}.

A platform object should be bundled together with an application. It is created by the developer of an application and then serialized to disk, together with the source code of the application. Whenever a user installs the application, all dependencies are installed along with the application code. Since there is no global namespace, the platform acts as a sandbox. Different applications and platforms cannot interfere with each other.

Parameterized classes in Newspeak can be used for external configuration of classes in a way that is similar to \msname. Whenever a class is paramterized and stores its arguments in slots, methods in the current class and nested classes can access these slots, because Newspeak automatically creates accessor methods for all slots. When \texttt{scope} in \msname does the method lookup, it first searches for methods in the class, and then checks if there is a parameter for the class with that name. Afterwards, it continues the lookup in the enclosing class. An implicit receiver lookup in Newspeak immediately finds the corresponding accessor method.
%https://www.cs.cmu.edu/~aldrich/papers/objects-essay.pdf

\subsection{Dependency Installation}
\label{sec:rel_metacello}
In this section, we briefly describe dependency/package management systems for different programming languages.

\paragraph{Metacello}
Metacello\footnote{\url{https://github.com/dalehenrich/metacello-work}} is a package management system for Smalltalk (multiple dialects). It can be used to load applications and libraries into a system and supports various backends, such as Monticello or github. Every Metacello project is represented by a \emph{configuration class} and consists of a set of versions, modelled as instance methods of the configuration. Every version is a set of packages in a certain Monticello version. The configuration class also contains URLs to remote repositories and other dependent projects~\cite{metacellodraft}.

Whenever a project is loaded, Metacello retrieves all packages from the (remote) repositories specified in the configuration class in the requested versions. Already existing classes are replaced during filein. It is not possible to install multiple versions of a Metacello project side by side.

\paragraph{Maven}
A Java class loader loads compiled Java classes into a running virtual machine. It can be used to load classes dynamically at runtime by specifying their names. Maven is a \emph{software project management and comprehension tool}. It stores dependencies in a repository on the file system and loads them using a Java class loader. Maven projects have a \texttt{pom.xml} configuration file that contains a listing of all dependencies required by the project. When the project is run, Maven ensures that all dependencies are available in the repository or downloads them from a remote server, otherwise. It then compiles the project and runs it.

Maven is a widely-used tool, not only for open-source projects, but also for enterprise applications. In 2014, the Maven central repository hosted more than \num[group-separator={,}]{17000} projects and more than \num[group-separator={,}]{115000} versions in total, amounting to about 265 GB of data~\cite{Mitropoulos:2014:BCM:2597073.2597123}.

Every Maven dependency declared in \texttt{pom.xml} should have a version. A version can be an exact version number (e.g., \texttt{[1.1]}) or a version range. For example, if all versions smaller or equal to \texttt{1.0} are acceptable, the programmer can write \texttt{(,1.0]}. Another example is \texttt{[1.0,2.0)}, meaning that all versions between \texttt{1.0} (including) and \texttt{2.0} (excluding) are acceptable~\cite{books/daglib/0021697}. The way Maven specifies versions is similar to \msname. However, Maven cannot load more than one version of a library at a time. There would be no way to reference a certain version of a library in the Java code, because all the programmer does is writing down the fully qualified name of a class contained in a dependency. The version number is usually not part of the fully qualified class name. In \msname, it is.

Maven dependencies are transitive. If \texttt{A} requires \texttt{B}, and \texttt{B} requires \texttt{C}, then adding \texttt{A} as a dependency will automatically add \texttt{B} and \texttt{C} as dependencies. The programmer does not have to specify these dependencies explicitly.
%todo: OSGI

\paragraph{RubyGems}
RubyGems is a package manager for Ruby. Libraries and applications are contained in \emph{gems}. Gems can be installed using the command line tool \texttt{gem} and are hosted at a central repository\footnote{\url{http://rubygems.org}}. The programmer has to \emph{require} (import) the package \texttt{rubygems} in his application. Afterwards, installed RubyGems can be imported by adding corresponding \texttt{require} statements. Specific versions of a gem can be imported by adding a \texttt{gem} statement in front of the \texttt{require} statement. For example, \texttt{gem "extlib", "\textgreater = 1.0.8"}, followed by \texttt{require "extlib"} imports the library \texttt{extlib} in a version that is guranteed to be greater or equal to \texttt{1.0.8}~\cite{rubygemsguide}. 

\emph{Bundler}\footnote{\url{http://bundler.io/}} is a dependency manager for RubyGems. The programmer can add a \texttt{Gemfile} to the root directory of an application. All dependencies are automatically downloaded and installed when the programmer executes the command line statement \texttt{bundle install}.

\section{Readability and Understandability}
In object-oriented, class-based programming languages, source code is typically structured on multiple levels. Classes are used to group common behavior for a set of objects. Inside a class, methods are used to divide source code into smaller, more managable pieces. In this section, we give an overview of how classes can be structured in other programming languages, in order to increase readability and understandability of source code.

\subsection{Smalltalk Packages}
In Smalltalk, packages are used as deployment units. Usually, the programmer can already tell by the name of a package, what the responsibilities of a certain package are. For example, in Figure~\ref{fig:usecase_sc_origi_fig}, all item classes are contained in the package \texttt{SpaceCleanup-Items}. Similarly, all UI-related classes are contained in \texttt{SpaceCleanup-UI}. Packages make it easier to find a certain class whose name is unknown to the programmer. They also make it easier to understand in what context a certain class is used.

\subsection{Hierarchical Decomposition}
As described in Section~\ref{sec:rel_ns_pkg_cls_nesting}, many programming languages such as Java, Python, Ruby, or Newspeak, have a concept of packages, namespaces, and/or nested classes. These concepts allow for a form of hierarchical decomposition. Smalltalk packages allow the programmer to put classes in a certain package, according to their responsibilites. The mentioned concepts make it possible to structure classes on a more accurate level. Packages, namespaces, and nested classes act as a form of information hiding, because implementation details are hidden from the programmer. Only when examining the next nested level, the programmer is confronted with  another level of details. In Section~\ref{sec:problem_hier_decomp}, we give an overview of the benefits of hierarchical decomposition.
%Java, Python, Ruby, Newspeak, \ldots

%\subsection{Java Interfaces}
%Java interfaces are used to decouple code from specific implementations. Instead of mentioning a class explicitly, the programmer uses an interfaces describing all public methods of the type. Java interfaces are, therefore, a form of information hiding.

\section{Code Reuse}
In this section, we give an overview of how other programming languages promote code reuse. Composition and inheritance are the most basic form of code reuse in class-based programming languages. We focus on concepts that are similar to the ones used in \msname.

\subsection{Multiple Inheritance}
\label{sec:rel_mult_inhh}
In programming languages with multiple inheritance, a class can be a subclass of more than just one superclass. Examples of programming languages supporting multiple inheritance are C++, Eiffel, or Python. Multiple inheritance is controversial because of the \emph{diamond problem}: imagine that a class inherits from two classes and both classes provide the same method. Which implementation should be used in the subclass? In C++, this problem is solved by specifying explicitly, which implementation to use. In Python, the order of superclasses matters and the superclass hierarchy is flattened to a single inheritance graph (C3 linearization~\cite{pythonmro23}).

\subsection{Mixins}
\label{sec:rel_mixins1}
Mixins are an alternative to multiple inheritance. A class can inherit from a single class, but multiple mixins can be mixed into the inheritance hierarchy. Mixins can also be seen as abstract subclasses, class transformators, or class functions. Mixins can be implemented in programming languages using one of the following mechanisms.

\paragraph{Explicit Programming Language Support}
The programming language provides an explicit mixin construct (as part of the syntax), effectively making mixins part of the language definition.

In Ruby, modules can be used as mixins. When a module is included in a class (using the \texttt{include} statement), the module is added to the inheritance chain as a superclass. Consequently, when a mixed-in method calls \texttt{super}, the lookup searches for methods in the list of previously mixed-in modules, and then in the superclass. However, the \texttt{superclass} method skips mixed-in modules.

MixedJava is an extension of the Java programming language, introducing a \texttt{mixin} notation (extension of the Java syntax)~\cite{Flatt:1998:CM:268946.268961}. Another example is McJava~\cite{mcjava}.

\paragraph{Class Nesting and Virtual Superclasses}
Whenever a programming language supports instance-side class nesting (non-static member classes) and virtual superclasses, the programmers gets mixins for free: create a container class \texttt{C} with an instance-side nested class \texttt{C.I}. The superclass of \texttt{C.I} is provided to instances of \texttt{C} as a constructor argument. \texttt{C.I} can then act as a mixin or class-to-class transformator by writing \texttt{(new C(superclass)).I}.

Java supports class nesting but does not support mixins, because superclasses are not virtual, i.e., the superclass must be known at compile time. Newspeak supports mixins through instance-side nested classes and virtual superclasses. In \msname, classes can currently not be defined as instance-side members. Earlier versions \msname supported this feature (see Section~\ref{sec:future_inst_side}) and mixins could be implemented as described. At the moment, mixins can only be written using parameterized classes. 

\paragraph{Parameterized Classes}
In \msname, mixins can be implemented by creating a parameterized class, whose argument will be used as the superclass the mixin is applied to. In a similar way, C++ templates can be used to implement mixins: the parameter of a template is used as a superclass during template instantiation~\cite{mixinbasedcpp, nestedinterfaces}. 

Java generics cannot be used for mixins, because generic parameters cannot be used as superclasses. In fact, all generic class instantiations are represented by the same class. MixGen is an extension of the Java programming language, where generic parameters are first-class objects~\cite{Allen:2003:FAG:949305.949316}. MixGen does erase types upon compilation and supports mixins: a generic parameter can be the superclass of a generic class.

\paragraph{Linearization of Multiple Inheritance}
As described in Section~\ref{sec:rel_mult_inhh}, method resolution in programming languages with multiple inheritance can be ambiguous. Some programming languages have complicated rules for determining which method to use. Others require the programmer to resolve conflicts manually. Another solution to this problem is linearization: the superclass graph is flattened to a single inheritance graph (e.g., C3 linearization~\cite{pythonmro23}).

Multiple inheritance together with linearization can be used to implement mixins. In CLOS, mixins can be represented as classes~\cite{Smaragdakis:1998:ILD:646155.679703}. A mixin application is a new class whose superclasses are the mixin and the base class. Inside methods, \texttt{call-next-method} can be used to make super calls. For example, a mixin defined with \texttt{(defclass Mixin () ())} can be mixed into the base class \texttt{(defclass Base () ())} with \texttt{(defclass Mixin-application (Mixin Base) ())}. The method lookup will first look for methods in the mixins and then in the base class.

Python is another programming language that uses linearization of multiple inheritance. Mixins can be implemented in a similar way.

\paragraph{Meta Programming}
Mixins can be implemented using meta programming. For example, in Smalltalk, a customized \texttt{doesNotUnderstand:} handler could delete all failed message sends to a list of mixins stored as an instance variable. This approach provides only ``\emph{interface inheritance} instead of \emph{class inheritance}''~\cite{montlick1996implementing}.

%Ruby Modules, Python Multiple Inheritance, Newspeak, Jigsaw

\subsection{Traits}
\label{sec:rel_traits}
Traits are a form of code reuse and similar to Mixins. A trait is a ``composable unit of behavior''~\cite{traitsschaerli} (collection of methods). One or multiple traits can be applied when a class is defined. Traits do usually not change the superclass hierarchy. Instead, all trait methods are copied into the target class, i.e. traits can be ``compiled away''~\cite{Nierstrasz06flatteningtraits}. Conflicts (duplicate methods) have to be resolved manually by providing a method in the target class for every conflicting method. Such a method could call the implementation of either one of the traits.

Traits are available in both Pharo and Squeak. In Pharo, traits were used to modularize parts of the \emph{system kernel} and the collections library. Similar adaptions have been proposed for Squeak~\cite{PHDschaerli}. Featherweight-Trait Java is an extension of the Java programming language supporting traits~\cite{Nierstrasz06flatteningtraits}. Traits in Pharo and Squeak support removing methods from a trait upon composition, as well as renaming methods in a trait.

Schaerli et al. proposed traits as an alternative to mixins. They argue that conflict resolution is easier with Traits and that class hierarchies built by mixins are fragile~\cite{Schaerli_classes_is}.

Traits can be implemented in \msname on top of mixins. Mixins evolve out of class nesting in a natural way, which is, however, not the case for traits. For example, meta programming is necessary to call a trait method within a resolved method. Futhermore, meta programming is necessary to detect whether method conflicts arised during trait composition. Traits were implemented by adding a post-include hook to mixins, which is where \msname checks if methods are conflicting. 

Traitor\footnote{\url{https://github.com/txus/traitor}} is a library that adds support for Traits to Ruby. It is implemented by adding a \emph{method missing handler} and a collection of traits to every class. Whenever a message is not understood, the handler first checks for method conflicts and then goes through all traits applied to the class. Traits could be implemented in \msname in a similar way by adding a \texttt{doesNotUnderstand:} handler. The benefit of this approach is that the superclass hierarchy is not changed. One disadvantage is that the programmer cannot define another \texttt{doesNotUnderstand:}, since it would overwrite the handler defined by the library.

\subsection{Java Generics}
Java generics allow classes and interfaces to be parameterized by one or multiple classes and interfaces for type checking reasons~\cite{bracha2004generics, Bracha03addinggenerics}. They are often used together with collections~\cite{Parnin:2011:JGA:1985441.1985446}. Generic parameters are defined as part of the class or interface definition. When a class or interface is used, the programmer can pass classes and interfaces as arguments.

\begin{figure}[!htp]
\begin{lstlisting}
<@\textbf{class}@> Array<T> {
    T[] storage;

    <@\textbf{public}@> List(<@\textbf{int}@> size) {
        storage = <@\textcolor{gray}{\textit{/* ??? */}}@>;
    }

    T get(<@\textbf{int}@> index) {
        <@\textbf{return}@> storage[index];
    }

    <@\textbf{void}@> set(<@\textbf{int}@> index, T value) {
        storage[index] = value;
    }
}

Array<String> arr = <@\textbf{new}@> Array<String>(100);
\end{lstlisting}
\caption[Example: Generic array implementation using Java generics]{Example: Generic array implementation using Java generics. Due to type erasure, it is not obvious, how to allocate an array whose base type is a generic parameter.}
\label{fig:rel_java_generics}
\end{figure}

Figure~\ref{fig:rel_java_generics} shows how Java generics are used in practice. \texttt{T} is the generic parameter of the class \texttt{Array}. The compiler ensures that only arguments with the correct type \texttt{T} can be passed to \texttt{set()} and knows that \texttt{get()} can only return objects of type \texttt{T}. 

One shortcoming of Java generics is type erasure: generic type information is only known at compile time, but not at runtime. In contrast to C++ templates, there is only one \texttt{Array} class, regardless of how often the class is parameterized with different arguments~\cite{lembcke2006specialization}. Therefore, Java actually stores a reference to an array of type \texttt{Object[]}. It is difficult to initialize \texttt{storage} to an array of type \texttt{T}. In fact, the statement \texttt{new T[size]} does not compile. What the programmer could write instead is an unchecked type cast~\cite{nino2007cost}: \texttt{(T[]) new Object[size]}.

In \msname, a new class is created every time a parameterized accessor method is executed. Furthermore, arguments passed to the accessor method are available at runtime using message sends to \texttt{scope}.

\subsection{C++ Templates}
C++ templates allow classes to be parameterized with generic types. In contrast to Java generics, C++ generates a copy of the template, whenever it is used with a concrete type~\cite{vandevoorde2002cpp}. Consequently, every instantiation of a C++ templated class generates a new class, whereas all instantiations of a Java generic class are the same class (type erasure).

C++ templates are similar to parameterized classes in \msname in a sense that a new class is generated whenever a template/parameterized class is instantiated. However, new classes in \msname can be generated at runtime, whereas C++ templates are generated statically at compile time, as if they were a preprocessor transformation.
