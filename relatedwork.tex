\chapter{Related Work}
\label{sec:related}

\section{Class Name Clashes}

\subsection{Namespaces/Packages and Class Nesting}
Many programming languages have a concept of namespaces or packages. Classes are typically organized in a package, which is a set of classes. Classes within a package can usually reference each other directly. However, references to classes in other packages typically require imports, aliases, or a fully qualified name. Some programming languages also support class nesting, where the enclosing class creates a namespace for all inner/nested classes.

\paragraph{VisualWorks Namespaces}
VisualWorks is a commerical Smalltalk implementation sold by Cincom and supports namespaces~\cite{brauer2015programming}. A namespace is a container for other namespaces, classes, and shared variables. Since a namespace can be defined within another namespace, VisualWorks allows for a form of hierarchical decomposition. All namespace members (e.g., classes) in the same namespace can be referenced by just writing down their names. All namespace members in other namespaces can be referenced by writing down their fully qualified name, which is the concatenation of all nested namespace names and the name of the class with dots as separators. For example, the fully qualified name of a class \texttt{C1} in namespace \texttt{B} in namespace \texttt{A} is \texttt{A.B.C1}. Relatives name are also supported: for example, \texttt{A.B.C1} can be referenced as \texttt{B.C1} within \texttt{A}.

A namespace can import members from other namespaces by specifying a list of all imports when the namespace is defined~\cite{cincomst}. Wildcard imports are possible, importing all members of a namespace. Imported members can be referenced within a namespace as if they were part of that namespace. A namespace member can also be defined as \emph{private}; such a member cannot be imported, but always has to be referenced using its fully qualified name or using a relative name.

Namespaces are instances of the class \texttt{NameSpace}, which is a subclass of \texttt{Collection}. \texttt{NameSpace} defines a few helper methods to allow for meta programming, such as listing all classes or defining new namespaces or classes within a namespace.

\paragraph{Java Packages and Nested Classes}
The Java programming language has a concept of packages. A package is set of classes, interfaces, and pacckages, and corresponds to a directory on the file system. Classes and interfaces in the same package can be referenced directly using their name. Classes and interfaces in other packages can be referenced using their fully qualified name, which is generated exactly as in VisualWorks. They can also be imported explicitly, making it possible to reference them just using their name; wildcard imports are possible.

Classes and interfaces can be defined as package-public or package-private. Only package-public members can be imported or referenced within members outside of the current package.

Java supports the concept of nested classes: a class can either be a top-level class or a class that is nested within another member. There are four different kinds of nested classes~\cite{Bloch:2008:EJ:1377533}.
\begin{itemize}
	\item \emph{Static member class:} a class that belongs to another class, i.e., it is a static member of another class. It can be accessed like a static variable of the enclosing class. For example, if \texttt{B} is nested in \texttt{A}, it can be referenced with \texttt{A.B}. Messages sent from within the nested class are first looked up in the nested class and its superclass hierarchy, then on the class side of the enclosing class (static methods), and then in the enclosing class' enclosing class (if it is a nested class).
	\item \emph{Nonstatic member class:} a class that belongs to an instance of another class, i.e., it is a nonstatic member of another class. It is similar to a static member class, but the method lookup happens on the instance side of the enclosing class. Every instance of a class has its own nonstatic member classes; however, all of these classes must inherit from a class that can be resolved at compile time. Effectively, all nonstatic member classes are the same, with the only exception that they are bound to different enclosing objects.
	\item \emph{Anonymous class:} a class without a name. In older Java versions, it was frequently used as a substitute for missing block closures. Lambda expressions are available since Java 8, making anonymous classes obsolete in many use cases. Note, that since classes are not first-class objects in Java, it is difficult to pass anonymous classes around and to use them in a different context without using meta programming.
	\item \emph{Local class:} a class that can be defined anywhere where a local variable can be defined. It is the least frequently used kind of classes.
\end{itemize}

Static member classes are similar to packages. By just looking at source code that references a static member class, it is not obvious whether the class is statically nested or contained in a package.

Java imposes certain restrictions on member classes. For example, nonstatic member classes are not allowed to have static member which are not final~\cite{javalang1}. Furthermore, a subclass cannot override a member class definition~\cite{igarashi2002inner}; it can just define its own member class. The difference is that overriding implies late binding, which is not the case in Java. With \emph{Jx}, Nystrom et al. changed the Java language is such a way, that subclasses can enhance member classes~\cite{Nystrom:2004:SEV:1028976.1028986}: the new member class overrides the original one and is always a subclass and a subtype of the member class in the superclass. Jx also allows changing the superclass of a member class in a subclass of the enclosing class, a form of mixin modularity.

\paragraph{Ruby Modules}
Ruby has the concept of classes and modules. Modules are classes which are not instantiable. They can be included in classes and be used as mixins. Modules and classes can be nested in each other, defining a namespace. Classes and modules can be accessed using their fully qualified name, which is the concatenation of their names with two colons as separator. For example, if class \texttt{B} is nested in class \texttt{A}, \texttt{B}'s fully qualified named is \texttt{A::B}. Classes and modules can also be accessed using relative names. For example, when accessing \texttt{A::B}, Ruby first looks for \texttt{A} in the current class/module. If there no such member, it looks in the enclosing class/module.

In Ruby, a class can have methods, variables, and constants. An inner class or module is just a constant defined on the enclosing class. Constants are copied or shared during subclassing. Subclasses can replace inner classes with their own implementation. A nested class/module is always a class-side member of their enclosing class/module (nonstatic member class in Java).

In Ruby, classes and modules can be extended after they have been defined. In case of an accidential class/module name clash, the two (or more) classes/modules are effectively merged. In case of colliding methods, the method that was last seen (read from the file) overwrites all previous definitions. This process is often used deliberately in Ruby, in order change the behavior of a library or application, e.g., to fix a known bug (\emph{monkey patching})~\cite{Benson:2008:AR:1386543}. 

\paragraph{Python Modules}
In Python, every source code file is a module. Modules have to be imported, before they can be used within another module. Members defined in a module can be referenced by concatenating the module name and the name of the member (e.g., class or function) inside the module with a dot as a separator, if the module is imported. It is also possible to import single members from a module with their own name or an alias. These members can be accessed without writing down the module name.

In Python, every directory with a \texttt{\_\_init\_\_.py} source code file is a package. Packages can contain other packages and modules. Packages can be imported just like modules. The fully qualified name of a module is the concatenation of all package names and the module name, with a dot as a separator.

Modules in other packages can be imported by writing their fully qualified name or using a path relative to the current module~\cite{pythonp1}.

Python supports inner classes, but only for readability and understandability reasons, and their usage is not wide-spread. Inner classes are class-side members of the enclosing class. In fact, for every inner class, Python creates an attribute on the enclosing class object with the inner class name as name and the inner class object as value. Since all nested class attributes are copied during subclassing, a subclass shares the same inner classes as the superclass. Redefining an inner class on the superclass simply replaces it. Inner classes do not affect the class lookup: for example, when two inner classes nested on the same level want to reference each other, both have to write their \emph{full path} (i.e., sequence of attribute reads).

Whenever a top-level class is defined and there is already a class with that name in the same module, the new class replaces the existing one.

\subsection{Squeak Environments}
\label{sec:rel_sq_env}

\subsection{Newspeak Modules}


\section{Dependency Management}

\subsection{Metacello}
\label{sec:rel_metacello}

\subsection{Java Class Loader}

\subsection{Separate Compilation}

\subsection{Dependency Injection}
%http://www.jot.fm/issues/issue_2012_04/article3.pdf

\subsection{External Configuration in Newspeak}


\section{Readability and Understandability}

\subsection{Smalltalk Packages}

\subsection{Hierarchical Decomposition}
Java, Python, Ruby, Newspeak, \ldots

\subsection{Information Hiding with Interfaces}


\section{Code Reuse}

\subsection{Multiple Inheritance}

\subsection{Mixins}
Ruby Modules, Python Multiple Inheritance, Newspeak, Jigsaw

\subsection{Traits}
\label{sec:rel_traits}
Squeak implementation

\subsection{Java Generics}
Java generics allow classes and interfaces to be parameterized by one or multiple classes and interfaces for type checking reasons~\cite{bracha2004generics}. Theya are often used together with collections~\cite{Parnin:2011:JGA:1985441.1985446}. Generic parameters are defined as part of the class or interface definition. When a class or interface is used, the programmer can pass classes and interfaces as arguments.

\begin{figure}[!htp]
\begin{lstlisting}
class Array<T> {
    T[] storage;

    public List(int size) {
        storage = /* ??? */;
    }

    T get(int index) {
        return storage[index];
    }

    void set(int index, T value) {
        storage[index] = value;
    }
}

Array<String> arr = new Array<String>(100);
\end{lstlisting}
\caption{Generic array implementation using Java generics}
\label{fig:rel_java_generics}
\end{figure}

Figure~\ref{fig:rel_java_generics} shows how Java generics are used in practise. \texttt{T} is the generic parameter of the class \texttt{Array}. The compiler ensures that only arguments with the correct type \texttt{T} can be passed to \texttt{set()} and knows that \texttt{get()} can only return objects of type \texttt{T}. 

One shortcoming of Java generics is type erasure: generic type information is only known at compile time, but not at runtime. Therefore, Java actually allocates a storage array of type \texttt{Object[]}. Therefore, it is difficult to initialize \texttt{storage} to an array of type \texttt{T}. In fact, the statement \texttt{new T[size]} does not compile. What the programmer could write instead is an unchecked type cast~\cite{nino2007cost}: \texttt{(T[]) new Object[size]}.

\subsection{C++ Templates}
